# 프렉탈 평면

| 시간 제한 | 메모리 제한 | 제출   | 정답  | 맞힌 사람 | 정답 비율   |
| ----- | ------ | ---- | --- | ----- | ------- |
| 2 초   | 128 MB | 1660 | 735 | 566   | 45.535% |

## 문제

프렉탈 평면은 다음과 같이 커진다. 시간 0에서 프렉탈은 흰색 정사각형 하나이다. 단위 시간(1)이 진행될 때마다 N×N개의 크기가 동일한 단위 정사각형으로 나누어진다. 만약 나누어진 정사각형이 흰색이라면 가운데 K×K 정사각형이 검정색으로 채워진다. N과 K는 둘 다 홀수이거나, 둘 다 짝수이다.

예를 들어, N=3, K=1이라면, 시간 1에 3×3 정사각형이 된다. 가운데 정사각형은 검정색이고, 나머지는 흰색이 된다. 시간 2때 9×9 정사각형이 되고, 17개는 검정이고, 나머지는 흰색이다.

![](https://upload.acmicpc.net/209f7362-9252-4bb8-b40d-91e115e42cf3/-/preview/)

s, N, K, R1, R2, C1, C2가 주어질 때, 시간 s일 때, R1행 C1열부터 R2행 C2열까지의 모습을 출력하는 프로그램을 작성하시오.

## 입력

첫째 줄에 7개의 정수 s, N, K, R1, R2, C1, C2가 주어진다.

## 출력

첫째 줄에 문제의 정답을 출력한다. 첫째 줄에 R1행의 모습을 출력하고 이런 식으로 총 R2-R1+1개의 줄에 출력하면 된다. 각 행의 모습을 출력할 때, C1열부터 C2열까지 차례대로 흰색이면 숫자 '0' 검정이면 숫자 '1'을 출력한다. 숫자 사이에 공백을 넣으면 안 된다.

## 제한

- 0 ≤ s ≤ 10
- 3 ≤ N ≤ 8
- 1 ≤ K ≤ N - 2
- (N - K) mod 2 = 0
- 0 ≤ R1, R2, C1, C2 ≤ Ns - 1
- R1 ≤ R2 ≤ R1 + 49
- C1 ≤ C2 ≤ C1 +49

![](C++_20220921_백준1030_프렉탈%20평면assets/2022-09-21-23-04-02-image.png)

![](C++_20220921_백준1030_프렉탈%20평면assets/2022-09-21-23-04-15-image.png)

## 나의 코드

```c
#include <iostream>
using namespace std;
char M[51][51];

int main(void) {
    int s, N, K, R1, R2, C1, C2;            //시간, 배열크기, 검은상자크기, 행시작,행끝,열시작,열끝
    int a, b, c, x, y;
    cin >> s >> N >> K >> R1 >> R2 >> C1 >> C2;
    int section[11] = {1,};
    for (int i = 0; i < 50; i++)
    {
        for (int j = 0; j < 50; j++)
            M[i][j] = '0';                 // 0으로 초기화 
    }
    for (int i = 1; i <= s; i++)
    {
        section[i] = section[i - 1] * N;   //s값에 따라 패턴 사이즈들 저장. 
    }
    for (int w = 1; w <= s; w++)
    {
        a = section[w];                  // 패턴의 1변의 크기.
        b = ((a - K*section[w-1]) / 2); // 패턴과 한쪽 변 사이의 거리 
        c = a - b;                      // 패턴 반대쪽과 한쪽 변 사이의 거리. 
        for (int i = R1; i <= R2; i++)
        {
            for (int j = C1; j <= C2; j++)
            {
                y = i % a;               // 패턴 길이로 나눈 나머지를 통해서 칠한다. 
                x = j % a;
                if (b <= y && y < c && b <= x && x < c) // 만약 나눈값이 검은색 칠할 영역 이라면 '1'로 칠한다.
                {
                    M[i - R1][j - C1] = '1';
                }
            }
        }

    }
    for (int i = 0; i <= R2-R1; i++)
    {
        for (int j = 0; j <= C2-C1; j++)
        {
            cout << M[i][j];
        }
        cout << '\n';
    }

}
```

![](C++_20220921_백준1030_프렉탈%20평면assets/2022-09-21-23-05-01-image.png)

나는 50x50배열을 만들어 사용했기 때문에, 메모리가 더 많이 들었고 시간도 더 많이 들었을 것이다. 이렇게 하기보단 바로바로 아래의 코드처럼 출력했으면 훨씬 좋았을 것 같다.

## 다른 사람 코드 (메모리 적고 빠른 코드)

```c
#include<cstdio>
using namespace std;
int main(){
    int s,N,K,R1,R2,C1,C2,xt,yt,i,j,k;
    scanf("%d %d %d %d %d %d %d",&s,&N,&K,&R1,&R2,&C1,&C2);
    for(i=R1;i<=R2;i++){
        for(j=C1;j<=C2;j++){
            xt=i,yt=j;
            for(k=0;k<s;k++){
                if((xt%N >= (N-K)/2) && (xt%N <(N+K)/2)&&(yt%N>=(N-K)/2)&&(yt%N<(N+K)/2)){
                    printf("1");
                    break;
                }
                xt/=N;
                yt/=N;
            }
            if(k==s)
                printf("0");
        }
        printf("\n");
    }
}
```

![](C++_20220921_백준1030_프렉탈%20평면assets/2022-09-21-23-05-57-image.png)

이 코드가 메모리가 적은 이유로는 scanf 와 printf를 쓴 것이 있을 것이라 생각한다. 그런데 그보다, 따로 1번 더 도는 것이 아니라 한번에 돌면서 판정하면 바로 출력하는 점에서 훨씬 빠를수 밖에 없었다고 생각한다.
