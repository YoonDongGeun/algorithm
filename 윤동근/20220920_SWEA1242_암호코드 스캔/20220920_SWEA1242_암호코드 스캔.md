[S/W 문제해결 응용] 1일차 - 암호코드 스캔 D5

- 시간 : 20개 테스트케이스를 합쳐서 *C++의 경우 10초* / *Java의 경우 20초* / *Python의 경우 30초*

- 메모리 : 힙, 정적 메모리 합쳐서 *262144 kbytes* 이내, 스택 메모리 *1024 kbytes* 이내

※ SW Expert 아카데미의 문제를 무단 복제하는 것을 금지합니다.  

어떤 국가에서는 자국 내 방송국에서 스파이가 활동하는 사실을 알아냈다.  

스파이는 영상물에 암호 코드를 삽입하여 송출하고 있었다.  

암호 코드는 국가 내 중요 시설을 의미하는 숫자임을 알아냈다. 암호 코드의 규칙은 아래와 같다.  
 

1. 총 8개의 숫자로 이루어져 있다.  

2. 앞 7자리는 상품 고유의 번호를 나타내며, 마지막 자리는 검증 코드를 나타낸다.  

    - 검증코드는 아래와 같은 방법으로 계산한다.  

    “(홀수 자리의 합 x 3) + 짝수 자리의 합 + 검증 코드” 가 10의 배수가 되어야 한다.  

    상품 고유의 번호가 8801234일 경우,  

    “( ( 8 + 0 + 2 + 4 ) x 3 ) + ( 8 + 1 + 3 ) + 검증 코드”  

    = “42 + 12 + 검증 코드”  

    = “54 + 검증 코드” 가 10 의 배수가 되어야 하므로, 검증코드는 6이 되어야 한다.  

    즉, 88012346 이 정상적인 암호코드고, 그 외의 검증코드가 포함된 경우 비정상적인 암호코드다.  

A 업체에서는 이 암호코드들을 빠르고 정확하게 인식할 수 있는 스캐너를 개발하려고 한다. 스캐너의 성능은 아래와 같은 방법으로 측정된다.  
 1. 세로 2000. 가로 500 이하의 크기를 가진 직사각형 배열에 암호코드 정보가 포함되어 전달된다. 이 때, 하나의 배열에는 1개 이상의 암호코드가 존재한다. (단, 모든 암호코드가 정상적인 암호코드임을 보장할 수 없다. 비정상적인 암호코드가 포함될 수 있다.)  

2. 배열은 16진수로 이루어져 있으며, 이 배열을 2진수로 변환하여 그 안에 포함되어 있는 암호코드 정보를 확인한다.  

3. 포함된 암호코드들의 검증코드를 확인하여 정상적인 암호코드인지 확인한다.  

4. 정상적인 암호코드들을 판별한 뒤 이 암호코드들에 적혀있는 숫자들의 합을 출력한다.  

5. 이때, 총 소요시간이 적을수록 성능이 좋은 것으로 간주된다.  

배열에 포함되어 있는 암호코드의 세부 규칙은 아래와 같다.  
 1. 암호코드 하나는 숫자 8개로 구성되며 시작 구분선, 종료 구분선은 별도로 존재하지 않는다.  

2. 암호코드들이 붙어있는 경우는 존재하지 않는다. (각 암호코드의 둘레에는 최소 1칸 이상의 빈 공간이 존재한다.)  

3. 암호코드가 일부만 표시된 경우는 없다. 모든 암호코드는 8개의 숫자로 구성되어 있다.  

4. 암호코드의 세로 길이는 5 ~ 100 칸이다.  

5. 암호코드의 가로 길이는 암호코드 선의 두께에 따라 달라지며, 두께가 가장 가는 경우, 숫자 하나가 차지하는 길이는 7칸 이다. 각 숫자들을 그림으로 표시하는 방법은 다음과 같다.  
    ![](20220920_SWEA1242_암호코드%20스캔assets/2022-09-21-11-13-37-image.png)![](20220920_SWEA1242_암호코드%20스캔assets/2022-09-21-11-13-51-image.png)



각 숫자는 흰색과 파란색의 넓이 비로 표현된다. 암호코드의 가로 길이가 길어질 경우, 숫자 하나가 차지하는 길이는 7의 배수가 된다. 예를 들어, 가로 길이가 2배가 될 경우 9는 아래와 같이 표시될 수 있다.  
 ![](20220920_SWEA1242_암호코드%20스캔assets/2022-09-21-11-14-01-image.png)



6. 암호코드 하나의 최소 가로 길이는 56이며, 암호코드 선이 굵어질 경우, 56의 배수의 길이를 갖게 된다. 예를 들어 암호코드 숫자 하나가 14칸을 사용하는 경우, 암호코드 하나의 가로길이는 112가 된다. 암호코드 하나에 포함되는 암호코드 숫자들은 모두 동일한 크기를 갖는다.  
   암호코드 정보가 포함된 2차원 배열을 입력으로 받아 정상적인 암호코드를 판별하는 프로그램을 작성하라.  

**[입력]**  

표준 입력으로 T개의 테스트 케이스가 이어져서 주어진다.  

각 테스트 케이스의 첫 줄에 두 자연수가 주어지는데 각각 배열의 세로 크기 N, 배열의 가로크기 M이다 (1≤N<2000, 1≤M<500).  

그 다음 N 개의 줄에는 M개의 배열의 값이 주어진다. 문제의 모든 배열의 값은 16진수이다.  

**[출력]**  

각 테스트 케이스의 답을 순서대로 표준출력으로 출력하며, 각 케이스마다 줄의 시작에 “#C”를 출력하여야 한다. 이때 C는 케이스의 번호이다.  

같은 줄에 빈칸을 하나 두고, 입력에 주어진 배열에서 정상적인 암호코드들에 포함된 숫자들의 합을 출력한다.  

**[참고]**  

각 테스트 케이스의 구성은 아래와 같다.  
 

| 테스트 케이스 | N * M      | 암호코드 가로 길이 | 암호코드 개수 |
| ------- | ---------- | ---------- | ------- |
| 그룹 1    | 100 * 26   | 56         | 1       |
| 그룹 2    | 200 * 50   | 56 ~ 112   | 2       |
| 그룹 3    | 500 * 126  | 56 ~ 280   | 5       |
| 그룹 4    | 1000 * 250 | 제한 없음      | 제한 없음   |
| 그룹 5    | 2000 * 500 | 제한 없음      | 제한 없음   |

**[예제 풀이]**  

1번 케이스의 암호코드 정보를 변환하면 아래와 같다.  

01110110110001011101101100010110001000110100100110111011  
01110110110001011101101100010110001000110100100110111011  
01110110110001011101101100010110001000110100100110111011  
01110110110001011101101100010110001000110100100110111011  
01110110110001011101101100010110001000110100100110111011  
01110110110001011101101100010110001000110100100110111011  
01110110110001011101101100010110001000110100100110111011  
01110110110001011101101100010110001000110100100110111011  
01110110110001011101101100010110001000110100100110111011  
01110110110001011101101100010110001000110100100110111011  
01110110110001011101101100010110001000110100100110111011  
01110110110001011101101100010110001000110100100110111011  
   
이 숫자가 나타내는 정보는 각각 아래와 같다.  
0111011(7) 0110001(5) 0111011(7) 0110001(5) 0110001(5) 0001101(0) 0010011(2) 0111011(7)  
   
검증코드가 맞는지 살펴보면, (7 + 7 + 5 + 2) * 3 + 5 + 5 + 0 + 7 = 80 이므로 올바른 암호코드라고 할 수 있다. 따라서 1번의 출력 값은 38이 된다.  
   
2번 케이스도 같은 방식으로 계산할 경우, 328D1AF6E4C9BB 는 14468227 이 되며, 검증코드가 틀렸음을 알 수 있다.  

196EBC5A316C578 는 18694956이 되며, 검증코드가 맞음을 알 수 있다.  

따라서 2번의 출력 값은 올바른 암호코드인 18694956의 값만 더한 48이 된다.

![](20220920_SWEA1242_암호코드%20스캔assets/2022-09-21-11-14-18-image.png)

## 나의 코드

```python
hex_bin = {'0': '0000', '1': '0001', '2': '0010', '3': '0011', '4': '0100', '5': '0101', '6': '0110', '7': '0111',
           '8': '1000', '9': '1001', 'A': '1010', 'B': '1011', 'C': '1100', 'D': '1101', 'E': '1110', 'F': '1111'}
 
secret = {(3, 2, 1): 0, (2, 2, 2): 1, (2, 1, 2): 2, (1, 4, 1): 3, (1, 1, 3): 4, (1, 2, 3): 5,
          (1, 1, 1): 6, (1, 3, 1): 7, (1, 2, 1): 8, (3, 1, 1): 9}
 
def cal(string, k):
    Length = 7*8*k
    string = (Length-len(string))*'0'+string # 크기에 맞지 않는 문자열이 들어왔으면 앞에 '0'을 갯수에 맞게 추가(암호 1개의 가로길이는 최대 100이니까 7*14=98이다. '000'이 최대 14개 나올수 있다. 이를 감안한 것
    S = 0                                    # 16진법으로 받을때 가장 앞, 뒤의 0을 모두 제외하고 받았기 때문에, 앞에 '0'의 갯수 부족할 수 있고, 실제로 부족하면 값이 달라진다.
    S2 = 0
    b = string[0]
    A = []
    ch = []
    cnt =0
    cnt2 =0
    for i in range(7 * 8 * k):
        if (string[i] == b):
            cnt += 1
        else:
            if(cnt2 == 3):
                b = string[i]
                cnt2 = 0
                cnt = 1
                ch.append(tuple(A))          # 튜플 형태로 암호의 앞에 3개만 가져오기. 3개의 숫자의 알아도 된다.
                A=[]
            else:
                b = string[i]
                A.append(cnt // k)
                cnt2 += 1
                cnt = 1
    ch.append(tuple(A))                     # 마지막 3개는 위의 for문에서 안들어가기 때문에 넣어주기.
    c=0
    for j in ch:                            # ch에 (1,2,3) 과 같은 암호의 비율들이 들어가 있다. ex)ch=[(1,2,3), (2,2,1), (1,2,1)...] (암호갯수 만큼)
        if c == 0:
            S += 3 * secret[j]
            S2 += secret[j]
            c=1
        else:
            S += secret[j]
            S2 += secret[j]
            c=0
    if S % 10 == 0:                         # S는 체크용, S2는 각 숫자의 합.
        return S2
    else:
        return 0                            # 불량 코드면 0 반환.
 
 
 
 
T = int(input())
for _ in range(1, T + 1):
    N, M = map(int, input().split())
    num_list = set()
    new_string = set()
    ans = 0
    for q in range(N):
        temp = input()
        A = int(temp, 16)
        if A and A not in num_list :    # 계산을 줄이기 위해, A를 10진법으로 바꿨을때, 0이거나 num_list 안에 있으면 넘어간다.(continue)
            num_list.add(A)             # 이미 사용한 문자열 담기.(num_list)
        else:
            continue
         
        st = 0                          # temp(input() 받은것)에서 '0'이 아닌지점의 시작지점 st
        ed = M-1                        # temp에서 '0'이 아닌지점의 끝지점 ed
        string =''
        while(temp[st] =='0'):
            st+=1
        while(temp[ed] =='0'):
            ed-= 1
        for i in range(st, ed+1):       # '0'아닌 지점의 시작지점, 끝지점 사이를 2진법 string으로 변환.
            string += hex_bin[temp[i]]
        start = (ed+1-st)*4             # temp의 변환한 문자 1개당 4글자이기 때문에, ed-st+1(기존 바꾸는 문자열길이)*4를 하면 string의 가장 끝지점의 인덱스가 나온다.
        for i in range((ed+1-st)*4, -1, -1): # string의 가장 끝부터 0번 인덱스까지 탐색.
            if i < start:                   # i번 인덱스가 start보다 작으면 시행. (start는 암호 탐색하면, 그 암호 길이만큼 뒤쪽에서 앞으로 start를 지정해준다.. (암호 길이만큼 탐색X)
                if string[i] == '1':        # 만약 1을 찾았으면, 암호코드계산.
                    f = 0
                    k = 0
                    cnt = 0
                    k = 1
                    while cnt!=4:           # cnt 는 0에서 1로 혹은 1에서 0으로 변환된 수. 0에서 1 혹은 1에서 0으로 4번째 바뀌면, 암호의 수 1개이다.ex) [1:3:1:2] 
                        if string[i-k] !=string[i-k+1]:
                            cnt +=1
                        k += 1              # 암호 1개의 길이가 몇인지 알수 있다.
                    k //= 7                 # k는 7로 나눠서 두께가 된다.
                    start = i + 1 - 7 * 8 * k   # i번째 인덱스에서 '1'을 찾았고 거기서 암호의 총 길이(7*8*k)만큼 빼준곳에서 암호가 시작된다.
                    if start < 0:           # 하지만 암호가 앞쪽에 있다면 start가 0 미만이 된다. 그렇기 때문에 0미만이면 start=0으로하고, cal 함수에서 '0'을 필요한 갯수만큼 달아준다.
                        start = 0
                    N2 = int(string[start:i + 1], 2)
                    if N2 not in new_string:
                        ans += cal(string[start:i + 1], k)  # 암호 판별 함수.
                        new_string.add(N2)                  # new_string에는 이미 쓴 암호 담기.
    print(f'#{_} {ans}')
```

![](20220920_SWEA1242_암호코드%20스캔assets/2022-09-21-11-14-48-image.png)

dd

## 다른 사람 코드

```python
def get_code(arr_i):
    result = set()
    for arr in arr_i:
        arr = arr.strip('0')
        if arr:
            num_b = bin(int(arr, 16))[2:].rstrip('0')
            tmp = num_b[-1]
            while num_b:
                chk = []
                cnt = 1
                for i in range(2, len(num_b)):
                    if num_b[-i] == tmp:
                        cnt += 1
                    else:
                        tmp = num_b[-i]
                        chk.append(cnt)
                        cnt = 1
                        if len(chk) == 4:
                            mult = min(chk)
                            result.add(num_b[-56*mult:][::-mult][::-1])
                            num_b = num_b[:-56*mult].rstrip('0')
                            break
    return result
 
 
def get_num(arr):
    result = []
    cnt_0 = 56 - len(arr)
    for _ in range(cnt_0):
        arr = '0' + arr
    for k in range(8):
        result.append(num_dict[arr[7 * k:7 * (k + 1)]])
    return tuple(result)
 
 
num_dict = {
    '0001101': 0, '0011001': 1, '0010011': 2, '0111101': 3, '0100011': 4,
    '0110001': 5, '0101111': 6, '0111011': 7, '0110111': 8, '0001011': 9
}
 
T = int(input())
 
for tc in range(1, T+1):
    N, M = map(int, input().split())
    matrix = set(input().rstrip() for _ in range(N))
    codes = get_code(matrix)
 
    num_code = set()
    for code in codes:
        num_code.add(get_num(code))
 
    answer = 0
    for code in num_code:
        chk = total = 0
        for i in range(8):
            if i % 2:
                chk += code[i]
            else:
                chk += 3 * code[i]
 
            total += code[i]
 
        if chk % 10:
            total = 0
        answer += total
 
    print(f'#{tc} {answer}')
```

![](20220920_SWEA1242_암호코드%20스캔assets/2022-09-21-11-17-34-image.png)


