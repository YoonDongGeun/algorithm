# 포도주 시식 성공

| 시간 제한 | 메모리 제한 | 제출     | 정답    | 맞힌 사람 | 정답 비율   |
| ----- | ------ | ------ | ----- | ----- | ------- |
| 2 초   | 128 MB | 106925 | 36309 | 26159 | 32.602% |

## 문제

효주는 포도주 시식회에 갔다. 그 곳에 갔더니, 테이블 위에 다양한 포도주가 들어있는 포도주 잔이 일렬로 놓여 있었다. 효주는 포도주 시식을 하려고 하는데, 여기에는 다음과 같은 두 가지 규칙이 있다.

1. 포도주 잔을 선택하면 그 잔에 들어있는 포도주는 모두 마셔야 하고, 마신 후에는 원래 위치에 다시 놓아야 한다.
2. 연속으로 놓여 있는 3잔을 모두 마실 수는 없다.

효주는 될 수 있는 대로 많은 양의 포도주를 맛보기 위해서 어떤 포도주 잔을 선택해야 할지 고민하고 있다. 1부터 n까지의 번호가 붙어 있는 n개의 포도주 잔이 순서대로 테이블 위에 놓여 있고, 각 포도주 잔에 들어있는 포도주의 양이 주어졌을 때, 효주를 도와 가장 많은 양의 포도주를 마실 수 있도록 하는 프로그램을 작성하시오. 

예를 들어 6개의 포도주 잔이 있고, 각각의 잔에 순서대로 6, 10, 13, 9, 8, 1 만큼의 포도주가 들어 있을 때, 첫 번째, 두 번째, 네 번째, 다섯 번째 포도주 잔을 선택하면 총 포도주 양이 33으로 최대로 마실 수 있다.

## 입력

첫째 줄에 포도주 잔의 개수 n이 주어진다. (1 ≤ n ≤ 10,000) 둘째 줄부터 n+1번째 줄까지 포도주 잔에 들어있는 포도주의 양이 순서대로 주어진다. 포도주의 양은 1,000 이하의 음이 아닌 정수이다.

## 출력

첫째 줄에 최대로 마실 수 있는 포도주의 양을 출력한다.

![](C++_20220926_백준2156_포도주%20시식assets/2022-09-26-21-43-15-image.png)

## 나의 코드

```c
#include <iostream>

int main(void) {
	int N, sol;
	int LS[10004];
	int LSS[10004];
	std::cin >> N;
	LS[0] = 0;
	LS[1] = 0;
	LS[2] = 0;
	LS[3] = 0;
	LSS[0] = 0;
	LSS[1] = 0;
	LSS[2] = 0;
	LSS[3] = 0;
	for (int i = 4; i < N+4; i++)
	{
		std::cin >> LS[i];
		if (LSS[i - 4]+LS[i-1] > LSS[i - 2] && LSS[i - 4]+LS[i-1] > LSS[i - 3]+LS[i-1])  // 이 케이스는 2잔 연속 안마신 후 2잔을 연속으로 마시는 경우이다. 이 케이스 때문에 여러번 돌렸다. 찾기가 힘들다...
		{
			LSS[i] = LS[i] + LS[i - 1] + LSS[i - 4];
		}
		else
		{
			(LSS[i - 2] + LS[i]) >= (LS[i] + LS[i - 1] + LSS[i - 3]) ? LSS[i] = LSS[i - 2] + LS[i] : LSS[i] = LS[i] + LS[i - 1] + LSS[i - 3];  // 계속 1칸 빼고 마시거나 그냥 마실때 최대갯수.
		}
		
	}
	LSS[N + 3] >= LSS[N + 2] ? sol = LSS[N + 3] : sol = LSS[N + 2];	 // 마지막에 안마시는 경우와 마시는 경우가 있으므로, 둘중 최대값.
	std::cout << sol << '\n';
}
```

![](C++_20220926_백준2156_포도주%20시식assets/2022-09-26-21-46-37-image.png)

처음에 계속 틀려서 많이 고민을 했다. 그리고 반례들을 찾아보니, 연속으로 2번 안마시고 다음에 2번 연속으로 마시는 경우도 있었다. 그래서 급하게 if문 1개를 추가하게 되었고, 바로 통과했다. DP로 이전 상태를 저장한 값에서 계속 값을 갱신하는 문제였다. 그런데 1가지 방법으로만 계속 갱신되는 것이 아니라, 이전값을 정하는 형태가 총 3가지가 있었다. 바로 처음에 말한 2번 안마시고 2번 연속으로 마시는 경우, 바로 전에꺼 마시고, 3번째 전꺼 마시는 최대값, 그리고 전에꺼를 안마시고 전전꺼를 마신 최대값에 더하는 것이다. DP문제를 풀때는 나올 경우의 수를 모두 고려하여 식을 짜야겠다는 것을 깨달았다. 맨날 1~2가지의 식만 나왔는데 3가지가 나올 줄은 몰랐다.

## 다른 사람 코드

```c
#include<stdio.h>
#include<algorithm>
using namespace std;
int main(){

	int N,n[10001],m[10001]={},t;

	scanf("%d",&N);
	for(t=1;t<=N;t++)scanf("%d",&n[t]);

	m[1] = n[1];
	m[2] = n[1] + n[2];
	for(t=3;t<=N;t++){
		m[t] = max(max(m[t-2] + n[t],m[t-3] + n[t-1] + n[t]),m[t-1]);
	}
	printf("%d",m[N]);
```

이 사람은 마시지 않는 경우를 가장 바깥의 max로 풀어냈다. 즉, 먼저 max 1번이 풀린후 그전의 최대값과 계속 마시는 경우의 최대값중 더 큰 값을 반환해서 마시지 않으면, 그냥 그전의 최대값을 그대로 가져오는 것이다.
