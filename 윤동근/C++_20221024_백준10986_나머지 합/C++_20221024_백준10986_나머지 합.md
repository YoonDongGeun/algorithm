# 나머지 합

| 시간 제한 | 메모리 제한 | 제출    | 정답   | 맞힌 사람 | 정답 비율   |
| ----- | ------ | ----- | ---- | ----- | ------- |
| 1 초   | 256 MB | 16189 | 4919 | 3603  | 28.755% |

## 문제

수 N개 A1, A2, ..., AN이 주어진다. 이때, 연속된 부분 구간의 합이 M으로 나누어 떨어지는 구간의 개수를 구하는 프로그램을 작성하시오.

즉, Ai + ... + Aj (i ≤ j) 의 합이 M으로 나누어 떨어지는 (i, j) 쌍의 개수를 구해야 한다.

## 입력

첫째 줄에 N과 M이 주어진다. (1 ≤ N ≤ 106, 2 ≤ M ≤ 103)

둘째 줄에 N개의 수 A1, A2, ..., AN이 주어진다. (0 ≤ Ai ≤ 109)

## 출력

첫째 줄에 연속된 부분 구간의 합이 M으로 나누어 떨어지는 구간의 개수를 출력한다.

![](C++_20221024_백준10986_나머지%20합_assets/2022-10-24-17-30-40-image.png)

## 나의 코드

```c
#include <iostream>
using namespace std;
long long NS[1000002];
long long CNS[1002];

int main(void)
{
	long long N, M, cnt=0;
	cin >> N >> M;
	cin.ignore();
	NS[0] = 0;
	long long temp;
	
	for (int i = 1; i <= N; i++) // 입력
	{
		cin >> temp;
		NS[i] = (temp + NS[i - 1])%M; // 누적합 더해가기
	}

	for (int i = 0; i < M; i++) // CNS는 숫자 i의 갯수. 
	{
		CNS[i] = 0;
	}

	for (int i = 1; i <=N; i++)
	{
		CNS[NS[i]]++;   // 숫자NS[i] 는 나머지 값을 의미. 그 나머지 값의 갯수 세기.
	}

	cnt += CNS[0];        // 숫자 0은 다른 값과 필요없이 혼자 나누어 떨어짐. 
	for (int i = 0; i < M; i++)
	{
		if (CNS[i] >= 2)
		{
			cnt += (CNS[i] * (CNS[i] - 1)) / 2;// 2개 이상인 값은, 그 값들중 2개를 고르는 경우의 수 만큼 구간 개수 생성 가능. 
		}
	}
	cout << cnt << '\n';
	return 0;
}
```

![](C++_20221024_백준10986_나머지%20합_assets/2022-10-24-17-32-59-image.png)

맨처음에는 브루트 포스 방식으로 해봤지만 당연히 시간초과였다. 그래서 다 누적해서 더하는 방법 까지는 생각했는데, 그다음 어떻게 할지 고민하다가 문제에 나머지 라는 말이 있어서, 모두 누적해도 나머지 값만 필요하다는 것을 알았다. 그리고 그 나머지 값이 같은 누적합끼리 빼면, 구간에서의 나머지 값이 나온다. 그래서 그 값들의 개수를 세서 문제를 해결하였다. 시간이 적게 걸린 코드들을 봤는데, 모두 cin 하는 과정을 다르게 했다. 그래서 cin하는 숫자가 100만개가 나올 수 있기 때문에, 한번에 cin하는 스킬을 가져야 단축할 수 있다고 생각한다.

## 다른 사람 코드(문자열로 받아서 빨리 cin하기)

```c

```


