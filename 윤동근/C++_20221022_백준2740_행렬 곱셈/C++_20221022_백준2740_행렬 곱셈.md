# 행렬 곱셈

| 시간 제한 | 메모리 제한 | 제출    | 정답   | 맞힌 사람 | 정답 비율   |
| ----- | ------ | ----- | ---- | ----- | ------- |
| 1 초   | 128 MB | 12670 | 8622 | 7489  | 69.575% |

## 문제

N*M크기의 행렬 A와 M*K크기의 행렬 B가 주어졌을 때, 두 행렬을 곱하는 프로그램을 작성하시오.

## 입력

첫째 줄에 행렬 A의 크기 N 과 M이 주어진다. 둘째 줄부터 N개의 줄에 행렬 A의 원소 M개가 순서대로 주어진다. 그 다음 줄에는 행렬 B의 크기 M과 K가 주어진다. 이어서 M개의 줄에 행렬 B의 원소 K개가 차례대로 주어진다. N과 M, 그리고 K는 100보다 작거나 같고, 행렬의 원소는 절댓값이 100보다 작거나 같은 정수이다.

## 출력

첫째 줄부터 N개의 줄에 행렬 A와 B를 곱한 행렬을 출력한다. 행렬의 각 원소는 공백으로 구분한다.

![](C++_20221022_백준2740_행렬%20곱셈assets/2022-10-24-20-51-32-image.png)



## 나의 풀이

```c
#include <iostream>
using namespace std;



int main(void)
{
	int N, M;
	int n, m;
	int X1[100][100];
	int X2[100][100];
	int X3[100][100];
	cin >> N >> M;
	for (int i = 0; i < N; i++)
	{
		for (int j = 0; j < M; j++)
		{
			cin >> X1[i][j];
		}
	}
	cin >> n >> m;
	for (int i = 0; i < n; i++)
	{
		for (int j = 0; j < m; j++)
		{
			cin >> X2[i][j];
		}
	}
	for (int i = 0; i < N; i++)
	{
		for (int j = 0; j < m; j++)
		{
			X3[i][j] = 0;
		}
	}

	for (int i = 0; i < N; i++)   // 세로 N
	{
		for (int j = 0; j < m; j++) // 가로 m
		{
			for (int k = 0; k < M; k++)
			{
				X3[i][j] += X1[i][k] * X2[k][j];
			}
		}
	}
	for (int i = 0; i < N; i++)
	{
		for (int j = 0; j < m; j++)
		{
			cout << X3[i][j] << ' ';
		}
		cout << '\n';
	}
}
```

분할 정복을 하는데 거치는 문제여서 풀었다. 왜 분할 정복인지 찾아보았다. 그결과 쉬트라센 알고리즘이라고 해서 위의 방식(일반 행렬 곱셈) 보다 약간 더 빠른 알고리즘이 있었다. 즉 기본 방식은 n^3이라면 쉬트라센은 n^2.81제곱의 시간복잡도를 갖는다. 그런데 매우 수학적으로 푼 방식이기 때문에, 외우기보다는 필요할때 찾아보는 것이 나을 것이라 생각한다.
