#include <iostream>
const int size = 1 << 16;
int N, X;
int M[16][16], Q[size];
int DP[16][1<<16];   // 0에서 시작. 모든 곳 순회후 끝. 0번 마지막 방문은 마지막에 더해주면 돼니까 1<<15로 충분 헷갈려서 16
					   // y축 사실 0번 인덱스도 없앨 수 있겠지만, 그러면 연산량이 많아질지도..?
void search();

int main(void)
{
	std::cin >> N;
	for (int i = 0; i < N; i++)
	{
		for (int j = 0; j < N; j++)
		{
			std::cin >> M[i][j];
		}
	}
	for (int i = 0; i < N; i++)
	{
		for (int j = 1; j < (1 << N); j++)
		{
			DP[i][j] = 17000000;
		}
	}
	DP[0][1] = 0;
	DP[0][0] = 17000000;
	search();
	std::cout << DP[0][0] << '\n';
	// 가장 끝에서 즉 모든 곳을 돌았을때 부터 시작 해서 가장 처음으로 간다. (나의 의식의 흐름) 끝에서 시작하면 탑다운. 아래에서 시작하면 다운 탑.
	// 1에서 2로 가는 최단, 1에서 3으로 가는 최단... 1에서 2거쳐 3으로가는 최단 1에서 4거쳐 3으로 가는 최단... 1에서 2거쳐 3거쳐 4로가는 최단 1에서 2거쳐 5거쳐 4로가는최단 1에서 3거쳐 5거쳐 4로가는 최단...
	// 1에서 1개거쳐 4로가는 최단은 1에서 3거쳐 4로가기 vs 1에서 2거쳐 4로가기 vs 1에서 5거쳐 4로가기
	// 1-2-3-4-5  1-2-4-3-5  1-3-2-4-5  1-3-4-2-5  1-4-2-3-5 1-4-3-2-5
	// 1-2-3-4    1-2-4-3    1-3-2-4    1-3-4-2    1-4-2-3   1-4-3-2
	// 1-2-3-4 vs 1-3-2-4        1-2-4-3 vs 1-4-2-3     1-3-4-2 vs 1-4-3-2  흐름 생각 결론
	// 중간에 못가면 어떻게 처리할 것인가. 최소값은 어떻게 불러오는 것이 효율 적일것인가. 경로 변경에 따른 영향은?
	// 저장 형태 X(1000 0100 0111...) 에서 현재 위치에 따른 값들은 1인 곳만 가능. 그곳에서 어디로 도착할 것인가.
	// 위 상태에서 가야할 곳들중. 못가는 곳을 처리. 갈 수 있는 곳은 갱신 하지만 현재 값은 가장 낮은 값으로
	// 가장 낮은 값에서 갈 수 있는 곳을 적용 하는 것이 거칠때의 최단거리
	// 1,1000 2,0100 3,0010 4,0001 
	// 2,1100 3,1010 4,1001
	// 1,1100 3,0110 4,0101
	// 1010 0110 0011
	// 1001 0101 0011
	// 3, 1110(최소값 결정) 4,1101
	// 3, 1110(다시 안해도돼) 4,1011
	// 1101 1011
	// ...
}

void search()
{
	int NEW, NEW2, st, md, ed, X;
	st = 0, ed = 1;
	Q[st] = 1;
	while (st != ed)
	{
		md = ed;
		while (st != md)
		{
			X = Q[st++];
			st &= ~size;
			for (int i = 1; i < N; i++)
			{
				if (X & (1 << i))  //이미 간곳은 넘겨
				{
					continue;
				}
				else              // 안 간곳 가자
				{
					NEW2 = X | (1 << i);
					if (DP[i][NEW2] != 17000000)  // 이미 계산 됐으면 넘겨
					{
						continue;
					}
					DP[i][NEW2] = 17000001;
					Q[ed++] = NEW2;
					ed &= ~size;
					for (int j = 0; j < N; j++) //어디서 오는 것이 최소값
					{
						if ((X & (1 << j)) && (DP[j][X] != 17000000)) // 이미 갔던곳 시작 j에서 i로
						{
							if (M[j][i])		 // 갈수 있으면 가자
							{
								NEW = M[j][i] + DP[j][X];
								if (DP[i][NEW2] > NEW)
								{
									DP[i][NEW2] = NEW;
								}
							}
						}
					}
					//DP[갈곳의 위치][갈곳] 갱신완료
				}
			}

		}
	}

	for (int i = 1; i < N; i++)
	{
		if (M[i][0] && DP[0][0] > M[i][0] + DP[i][(1 << N) - 1])
		{
			DP[0][0] = M[i][0] + DP[i][(1 << N) - 1];
		}
	}
}