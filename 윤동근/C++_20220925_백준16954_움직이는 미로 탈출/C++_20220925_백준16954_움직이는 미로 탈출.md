# 움직이는 미로 탈출

| 시간 제한 | 메모리 제한 | 제출    | 정답   | 맞힌 사람 | 정답 비율   |
| ----- | ------ | ----- | ---- | ----- | ------- |
| 2 초   | 512 MB | 10222 | 3241 | 2024  | 27.504% |

## 문제

욱제는 학교 숙제로 크기가 8×8인 체스판에서 탈출하는 게임을 만들었다. 체스판의 모든 칸은 빈 칸 또는 벽 중 하나이다. 욱제의 캐릭터는 가장 왼쪽 아랫 칸에 있고, 이 캐릭터는 가장 오른쪽 윗 칸으로 이동해야 한다.

이 게임의 특징은 벽이 움직인다는 점이다. 1초마다 모든 벽이 아래에 있는 행으로 한 칸씩 내려가고, 가장 아래에 있어서 아래에 행이 없다면 벽이 사라지게 된다. 욱제의 캐릭터는 1초에 인접한 한 칸 또는 대각선 방향으로 인접한 한 칸으로 이동하거나, 현재 위치에 서 있을 수 있다. 이동할 때는 빈 칸으로만 이동할 수 있다.

1초 동안 욱제의 캐릭터가 먼저 이동하고, 그 다음 벽이 이동한다. 벽이 캐릭터가 있는 칸으로 이동하면 더 이상 캐릭터는 이동할 수 없다.

욱제의 캐릭터가 가장 오른쪽 윗 칸으로 이동할 수 있는지 없는지 구해보자.

## 입력

8개 줄에 걸쳐서 체스판의 상태가 주어진다. '`.`'은 빈 칸, '`#`'는 벽이다. 가장 왼쪽 아랫칸은 항상 벽이 아니다.

## 출력

욱제의 캐릭터가 가장 오른쪽 윗 칸에 도착할 수 있으면 1, 없으면 0을 출력한다.

![](C++_20220925_백준16954_움직이는%20미로%20탈출assets/2022-09-26-23-12-42-image.png)

![](C++_20220925_백준16954_움직이는%20미로%20탈출assets/2022-09-26-23-12-53-image.png)

## 나의 코드

```c
#include <iostream>
struct way{
	int y;
	int x;
};
// 1. 움직이는 위치에 벽이 있는지 체크
// 2. 움직이는 위치의 위쪽에 벽이 있는지 체크
// 3. 밑에서 4번째 칸에 도착하면 완성

int main(void) {
	char M[8][9];
	int y, x, ny, nx, sol = 0, cnt = 0;
	int const save = 1 << 13;
	way pos[save] = { {7,0} };
	way move[9] = { {0,0},{0,1},{0,-1},{1,0},{-1,0},{1,1},{1,-1},{-1,1},{-1,-1} };
	int pb = 0, pm = 0, pt = 1;


	for (int i = 0; i < 8; i++)
		for (int j = 0; j < 8; j++)
		{
			std::cin >> M[i][j];
		}

	while (pt - pb)						// 큐의 시작점과 끝점이 만나면 break
	{
		pm = pt;
		while (pm - pb) {				// 큐의 시작점이 중간점까지 만나면 break;
			y = pos[pb].y;
			x = pos[pb].x;
			if (y == 3) {
				sol = 1;
				break;
			}
			
			for (int i = 0; i < 9; i++)	// 9가지 움직이는 방향 탐색
			{
				ny = y + move[i].y;
				nx = x + move[i].x;
				if (3 > ny || ny > 7 || 0 > nx || nx > 7)	// 범위 벗어나면 넘어가기
					continue;
				if (M[ny][nx] == '#' or M[ny - 1][nx] == '#')	// 벽이거나, 움직이는곳 위쪽에 벽이 있으면 넘어가기
					continue;
				pos[pt].y = ny;
				pos[pt].x = nx;
				pt++;
				pt &= ~save;
			}
			pb++;
			pb &= ~save;										// 큐 차면 초기화
		}
		if (sol)
			break;
		for (int i = 7; i > cnt; i--)
		{
			for(int j=0; j<8; j++)
				M[i][j] = M[i - 1][j];
		}
		for (int j = 0; j < 8; j++)
			M[cnt][j] = '.';
		cnt++;
	}
	std::cout << sol;
}
```

![](C++_20220925_백준16954_움직이는%20미로%20탈출assets/2022-09-26-23-14-19-image.png)

정답률이 낮아서 무서웠지만, 침착하게 하니까 금방 풀었다. 무엇보다 예전에 벽부수고 이동하기를 풀었던 것이 큰 도움이 된 것 같다. 이제 BFS는 어느정도 익숙해진 것 같고, DFS를 갈고 닦아야 할 것 같다. 이 문제는 약간의 BFS와 약간의 백트래킹이 필요한 문제라고 생각한다.

## 다른 사람 코드

```c
#include<ios>
int i, j, k;
bool a[9][8][8];
char s[9];

void dfs(int x, int y, int time) {
	if (a[time][x][y]) return;

	if (time > 7) {
		printf("1");
		exit(0);
	}
	
	for (int xx = x - 1; xx < x + 2; xx++)
		for (int yy = y - 1; yy < y + 2; yy++)
			if (xx >= 0 && xx < 8 && yy >= 0 && yy < 8)
				if (!a[time][xx][yy])
					dfs(xx, yy, time + 1);
}

int main() {
	for (; i < 8; i++) {
		scanf("%s", s);
		for (k = 0; i + k < 8; k++)
			for (j = 0; j < 8; j++)
				a[k][i + k][j] = s[j] == '#';
	}

	dfs(7, 0, 0);

	printf("0");
```

이 사람은 3차원 형식으로 매 시간마다 벽이 내려오는 것을 표현했다. 예를 들면 k가 0이면 시간 0일떄, k가 9이면 시간 9일때의 벽의 위치이다. 그리고 수학적으로 계산했을 때, 7번째 시간을 넘겨서 생존하면 벽이 모두 지나간 것이기 때문에 바로 1을 출력하게 했다.  그리고 

 a[k][i+k][j] = s[j]=='#'; 이 무슨뜻인지 몰랐는데 (s[j]=='#')을 먼저 연산한 것을 map안에 넣는 것이였다. 정말 이런 생각은 못해봤는데 본받아야할 거 같다. 즉, 벽은 1로 저장되고 벽이 아니면 0으로 저장된다. 그리고 이를 바탕으로 dfs를 했다.
