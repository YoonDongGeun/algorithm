# 20220807_백준2116_주사위쌓기_송경삼

**1. 문제**

![](20220808_백준2116_주사위쌓기_assets/2022-08-08-01-02-06-image.png)

우선 문제를 처음 읽었을 때, 옆면의 숫자를 기준으로 문제를 풀이 해야한다고 생각했습니다.

그렇게 주사위 하나하나를 돌면서 어떻게 놓아야할지 정하는 문제인줄 알고 풀이를 시작했습니다.



**2. 나의 풀이**

```python
o=[5,3,4,1,2,0]
    
def opp(n):         #반대 편의 위치를 반환하는 함수입니다.
    return o[n]
def opp_num(n,i):   #반대 편 위치의 값을 반환하는 함수입니다.
    return L[i][opp(L[i].index(n))]
def max_num(n,i):   #한 면이 정해졌을 때 4개의 옆면중 최대값을 반환하는 함수입니다.
    return max([x for x in L[i] if x!=n and x!=opp_num(n,i)]) 

L=[list(map(int,input().split())) for _ in range(int(input()))]
    #input을 받아 list로 정리합니다.
s=[0]*6 #sum 값을 저장할 리스트입니다.
t=[1,2,3,4,5,6] #초기의 아랫면 값이고, 새로운 값으로 갱신할 리스트입니다.

for i in range(len(L)): # L의 길이만큼 순회합니다.
    for j in range(6):  # 6개의 케이스를 돌면서
        s[j]+=max_num(t[j],i)
                #아랫면 값이 정해져있으므로 4개의 옆면 중 최대값을 더해줍니다.
        t[j]=opp_num(t[j],i)
                #t리스트를 다음 값으로 갱신해 줍니다.
print(max(s))      #6개의 케이스 중 최대값을 뽑습니다.
```

![](20220808_백준2116_주사위쌓기_assets/2022-08-08-00-57-43-image.png)

문제를 풀면서 첫 단추를 잘못 끼웠습니다. 이 문제는 옆면을 기준으로 푸는 것이 함정인 문제입니다. 모든 주사위는 아랫면이 정해지면 자동으로 윗면이 정해집니다. 따라서, 맨 밑의 주사위를 놓으면 그 위의 주사위들은 이미 윗면 아랫면이 다 정해집니다.

저는 그래서, 옆면이 아닌 아랫면을 기준으로 case를 1~6으로 놨습니다. case숫자는 아랫면에 해당하는 숫자가 놓아지는 경우입니다. 그리고, 반대편의 번호를 돌려주는 함수, 반대편의 숫자를 반환해주는 함수, 옆 4면 중 최대 숫자를 반환하는 함수를 구성해서 쉽게 해결했습니다.



**3. 다른풀이와 비교**

```python
import sys
input = sys.stdin.readline

n = int(input())
rotate = [5, 3, 4, 1, 2, 0]
dice_list = [list(map(int, input().split())) for _ in range(n)]
ans = 0

for bottom in range(1, 7):
    sum = 0
    for dice in dice_list:
        top = dice[rotate[dice.index(bottom)]]
        if bottom + top == 11: sum += 4
        elif bottom == 6 or top == 6: sum += 5
        else: sum += 6
        bottom = top
    if sum > ans: ans = sum
print(ans)
```

![](20220808_백준2116_주사위쌓기_assets/2022-08-08-00-59-22-image.png)

이번 문제는 의도하진 않았지만 랭커들과 비교해도 굉장히 짧은 길이로 풀어냈습니다. 하지만 시간에서 많은 차이가 났습니다. 그 이유들을 분석하고자 합니다. 우선, 저는 모든 case에 대해서 명확한 값을 구하고자  그래서 case를 6개로 나눠서 모든 경우의 수에서 최대값을 구했습니다. 왜냐하면 그리디한 방법으로 풀어내는 것이 최선의 판단이 나올 것이라는 확신이 없었기 때문입니다. 하지만 이 분의 방법이 제가 처음 생각했던 방법인 걸 보니 그리디한 방법도 최선의 수를 뽑아낼 수 있었다는 아쉬움이 남습니다.



**4. 느낀점**

아쉬운점은 max값을 유추하는데에 index함수와 max함수를 복잡하게 섞어서 안써도 됐을것 같다는 점입니다. 위 풀이처럼 4,5,6 중 무조건 한 값이 나오므로 if 문으로 나눠서 풀어도 됐을 것이라 생각합니다. 이렇게 index 함수가 굉장히 자주 쓰인 것이 시간이 오래 걸린 이유라고 생각하고 있습니다.

알고리즘을 공부하면 할수록 사람이 알아보기 쉬운 코딩과 컴퓨터가 수행하기 쉬운 코딩의 개념을 더 잘 알아야겠다고 생각이 듭니다.





*출처

https://www.acmicpc.net/problem/2116
