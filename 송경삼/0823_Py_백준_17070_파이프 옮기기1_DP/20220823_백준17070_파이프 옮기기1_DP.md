# 20220823_백준17070_파이프 옮기기1_송경삼

**1. 문제**



어제와 동일한 문제입니다. 어제는 DFS를 통해 완전탐색으로 풀었지만, 더 나은 방법을 찾기 위해 다른 방법으로 풀어보고자 시도했습니다.



**2. 나의 풀이**

```python
N=int(input())
Room=[[1]*(N+2)]+[[1]+list(map(int,input().split()))+[1] for _ in '_'*N]+[[1]*(N+2)]
    #index를 쉽게 다루기 위해 1로 둘러싼 배열을 만듭니다.
sub=[[[0,0,0]]*(N+2) for _ in '_'*(N+2)]    #각 좌표의 값을 갱신할 공간을 만듭니다.
                                            #[왼쪽에서 오는경우의수,대각선에서 오는경우의수,위쪽에서 오는 경우의수] 입니다.
sub[1][2]=[1,0,0] #초기값을 정해줍니다.
for i in range(1,N+1):  #이동 특성상 j의 0,1,2 index는 절대 이동못하므로 순회하지않습니다.
    for j in range(3,N+1):
        if Room[i][j]==1:   #만약 해당 좌표가 이동불가능한 공간이라면 건너뜁니다.
            continue
        fr1=sub[i][j-1]     #왼쪽의 dp
        fr2=sub[i-1][j-1]   #대각선의 dp
        fr3=sub[i-1][j]     #위쪽의 dp
                #이동 가능한지 여부를 따지면서 dp를 갱신합니다.
        SUB1=fr1[1]+fr1[0] if Room[i][j-1]!=1 else 0    #첫번째값은 왼쪽칸에 왼쪽으로 도착한경우, 대각선으로 도착한 경우의 합입니다.
        SUB2=fr2[0]+fr2[1]+fr2[2] if Room[i-1][j-1]!=1 and Room[i-1][j]!=1 and Room[i][j-1]!=1 else 0   #대각선에서 오는건 다 더해줍니다.
        SUB3=fr3[1]+fr3[2] if Room[i-1][j]!=1 else 0    #마지막값은 위쪽칸에 위쪽으로 도착한경우,대각선으로 도착한 경우의 합입니다.
        sub[i][j]=[SUB1,SUB2,SUB3] #dp표를 갱신해줍니다
print(sum(sub[N][N]))   #모든 경우의 수를 합해줍니다.
```

![](20220823_백준17070_파이프%20옮기기1_DP_assets/2022-08-23-16-25-21-image.png)

솔직히 말해서, 완전탐색이 아닌 다른 방법이 더 나은 방법이라는 걸 알고 시작하니 풀이를 생각하기 쉬웠습니다. 그렇게 제가 한 풀이는 모든 경우의 수를 따지는 것이 아닌, 경우의 수 자체를 DP로 풀었습니다. 풀고 어제 기록과 비교해보니 굉장히 양호한 기록을 낼 수 있었습니다.



**3. 다른풀이와 비교**

```python
import sys
n = int(sys.stdin.readline())
house = sys.stdin.readlines()
house = list(map(lambda x: list(map(int, x.split())),house))
pipe = [[[0,0,0] for _ in range(n)] for _ in range(n)]
pipe[0][1][0] = 1
for i, x in enumerate(pipe[0][2:]):
	if house[0][i+2]:
		break
	pipe[0][i+2][0] = pipe[0][i+1][0]
for i in range(1, n):
	for j in range(1, n):
		if house[i][j]:
			continue
		pipe[i][j][0] = pipe[i][j-1][0]+pipe[i][j-1][1]
		pipe[i][j][2] = pipe[i-1][j][1]+pipe[i-1][j][2]
		if house[i-1][j] or house[i][j-1]:
			continue
		pipe[i][j][1] = sum(pipe[i-1][j-1])
print(sum(pipe[n-1][n-1]))
```

![](20220823_백준17070_파이프%20옮기기1_DP_assets/2022-08-23-16-28-48-image.png)

디테일은 많이 다르고, 부족하지만 랭커의 풀이와 거의 동일한 로직으로 접근했다는 것이 뿌듯했습니다. 요새 인덱싱을 할때 연산이 들어가는 것이 연산량이 많아지는것 같아 미리 변수로 지정하는 습관이 들었습니다. 하지만 더 빠른 랭커의 풀이를 보니 연산 속도에 그렇게 영향을 미치는 습관은 아니라고 생각이 듭니다. 또, 코딩 테스트 준비를 위해 sys 를 안쓰고있는데, 이 것이 얼마만큼의 속도차이를 내는지 궁금해졌습니다.



**4. 느낀점**

처음 풀이를 열어보고 어제 랭커 풀이를 안열어보고 다시풀겠다고한걸 잘 생각했다고 여겼습니다. 풀이를 열어봤으면 문제를 DP로 접근하는 사고자체를 해보질 않고 넘어갔을 것입니다. 그런데 지금 다시 이 문제를 처음 접한다면 완전탐색으로 풀 것 같은 느낌이 듭니다. 경험의 부족이라 생각하고 앞으로 접할 문제에는 고정된 사고로 시작하지 않도록 더욱 노력해야겠습니다.





*출처

https://www.acmicpc.net/problem/17070


