# 20220802_백준12865_평범한 배낭_송경삼

**1. 문제**

![](20220802_백준12865_평범한%20배낭_assets/2022-08-02-17-01-19-image.png)

**2. 문제 개인 의견**

우선, 이 문제도 과거에 손으로 한 번 풀어봤던 문제입니다. 하지만 그 때 무엇인가 어려웠던 기억이 남아있었고, 코딩으로 도전해보고자 선택했습니다. 그 때의 기억으론 동적계획법을 공부하려고 골랐던 문제였으나, 기준으로 삼을 변수가 무게, 가치 두 가지로 나뉘어있기에 완전 탐색을 써야하는 건가? 잠깐 판단이 흐릿해지기도 했던 문제입니다.

**3. 나의 풀이**

```python
import sys
N,K=map(int, sys.stdin.readline().split())  #물품의 숫자 N, 무게의 한도 K를 상수로 받습니다.
bag=[]  #물품을 저장할 공간입니다.

for i in range(N):
    bag.append(list(map(int, sys.stdin.readline().split()))) 
    #N개의 물품을 2차원 리스트에 저장합니다.

best=[[0]*N]    
#최선의 판단을 저장할 공간입니다.

for i in range(1,K+1):  
    # 첫번째 for문으로 무게를 순회합니다. 무게를 기준으로 삼은 이유는
    # 나중에 새로 갱신될 무게에서도 이전 무게에 대한 정보를 이용해 동적 계획법을 쓸 수 있기 때문입니다.

    i_best=[]       
    #무게 i일때 각 물품을 돌면서 베스트 판단을 저장할 임시공간입니다.

    for item in bag:        #배낭에있는 물품을 순회합니다.
        case1=i_best[-1] if i_best!=[] else 0          
        #case1은 해당 item을 포함하지않고 이전 item까지의 최선의 판단을 기록한 case입니다.

        case2=best[-1][len(i_best)]                    
        #case2는 해당 item을 넣었었던 이전의 최선의 case 입니다.

        if i_best!=[]:                                  
            case3=best[i-item[0]][len(i_best)-1]+item[1] if i-item[0]>=0 else 0
            #case3은 두가지로 나뉩니다. 해당 순회 차례가 맨 앞 물품이 아닐 때, 해당 물품을 넣으면서 최선의 가치를 낼 수있는 case입니다.
        else:               
            case3=item[1] if item[0]<=i else 0
            #해당 순회 차례가 맨 앞 물품이라면, 첫번째 물품을 넣을 수 있냐 마냐로 case가 변합니다.

        i_best.append(max(case1,case2,case3))   #case1~3중에 가장 가치가 큰 case를 저장합니다.

    best.append(i_best) #그렇게 전체 물품을 순회해서 모은 정보를 나중에 이용하기 위해 저장소에 저장합니다.

print(best[-1][-1]) #가장 마지막에 있는 요소가 최고의 값입니다.
```

![](20220802_백준12865_평범한%20배낭_assets/2022-08-02-17-39-13-image.png)

**4. 다른풀이와 비교**

```python
def get_max_value_case(K):
    dp = [0] * (K + 1)
    for w, v in WV:
        for i in range(K, -1, -1):
            if i-w < 0:
                break
            dp[i] = max(dp[i-w]+v, dp[i])

    return dp[K]

N, K = map(int, input().split())
WV = [list(map(int, input().split())) for _ in range(N)]
WV.sort()

print(get_max_value_case(K))
```

백준아이디 [msg012525](https://www.acmicpc.net/user/msg012525) 님의 풀이입니다.

![](20220802_백준12865_평범한%20배낭_assets/2022-08-02-17-39-54-image.png)

저보다 40%정도의 메모리를 아끼셨고, 8배정도의 빠르기, 3/5정도의 코드 길이로 푸셨습니다.

먼저, 처음에 가장 인상깊게 본 것은 sort()를 썼다는 점입니다. 물품의 개수 N이 100개 이하이므로 sort()를 써도 무관했고, 이렇게 알고리즘 자체를 접근 하는 방법을 더 쉽게 한 것 같습니다.

알고리즘을 분석한 결과 제 알고리즘과 가장 크게 다른 점은 저는 2차원 행렬의 갱신을 무게for문 안에 물품for문을 했다면, 이 분은 물품 for문 안에 무게 for문을 통했다는 점이었습니다. 제가 해당 문제를 풀면서 case1,2,3가 필요하다고 생각할 때, case2에 대해서는 꼭 필요한지에 대한 의문점을 가지고 있었습니다. 이분의 방법대로 풀었다면 case2가 별 의미없는 문제라고 활실하게 생각할 수 있었을 것 입니다.

또한, 이분은 이렇게 접근했기에, 1차원 배열만으로 메모리를 아낄 수 있었습니다. 저는 2차원배열을 이 분보다 더 많은 조건문을 통해 갱신해나갔기에 더 많은 메모리가 필요했습니다.

**5. 느낀점**

이 문제를 풀며 가장 크게 느낀 것은 코딩을 시작하기 막막할 때 종이로 아이디어를 적어보는 것이 정말 큰 도움이 된다는 것이였습니다. 아이디어를 한 번 확실히 정리하고 나니 어떤 부분을 시작점으로 어떻게 접근해야하는지 구현은 쉽게 할 수 있었습니다.

한 가지 궁금한 점은, 첫 제출을 python으로 해서 시간초과를 받았던 것이었습니다. pypy로 제출하면 시간에서 이득을 볼 수 있다는 팁을 알고 있기에 pypy로 다시 제출해서 정답은 맞았으나, 둘의 근본적인 차이가 무엇이길래 이렇게나 차이가 나는 건지 궁금해졌습니다.

동적 계획법을 다시 이해하는데에 큰 도움이 된 문제였습니다. 어떤 것을 기준으로 삼을지 다음부터는 좀 더 명확하게 구분할 수 있을 것 같습니다.



*출처

https://www.acmicpc.net/problem/12865






