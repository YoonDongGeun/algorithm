# 20221019_Cpp_백준_1655_가운데를 말해요_송경삼

### 1. 문제

![](1019_Cpp_백준_1655_가운데를%20말해요_assets/2022-10-19-15-03-47-image.png)

a



### 2. 나의 풀이

```cpp
#include <iostream>

int N;

//두 위치를 바꿔주는 함수입니다.
void swap(int* a, int* b) {
    int temp = *a;
    *a = *b;
    *b = temp;
}

//최대 힙 구조를 유지하면서 배열에 새로운 요소를 추가하는 함수입니다.
void push(int *heap,int idx, int num) {
    heap[idx] = num;
    while (idx >= 2 && heap[idx / 2] < heap[idx]) {
        swap(&heap[idx / 2], &heap[idx]);
        idx /= 2;
    }
}

//최대 힙 구조를 유지하면서 배열의 top을 교체하는 함수입니다.
void replace(int* heap,int idx, int num) {
    heap[1] = num;
    int a = 1;
    while (1) {
        if ((2 * a + 1 <= idx && heap[a]<heap[2 * a] && heap[2 * a]>=heap[2 * a + 1]) || (2 * a == idx && heap[a] < heap[2 * a])) {
            swap(&heap[2 * a], &heap[a]);
            a *= 2;
        }
        else if ((2 * a + 1 <= idx && heap[a] < heap[2 * a + 1] && heap[2 * a] < heap[2 * a + 1])) {
            swap(&heap[2 * a + 1], &heap[a]);
            a = 2 * a + 1;
        }
        else break;
    }
}


int main() {
    int max_heap[50005];
    int iM = 0;
    int min_heap[50005];
    int im = 0;
    int center;
    scanf("%d", &N);
    scanf("%d", &center);
    printf("%d\n", center);
    int sub;
    for (int n = 1; n < N; ++n) {
        scanf("%d", &sub);

        if (n % 2) { //새로운 항을 오른쪽 최소힙에 추가해야할 경우입니다.
            if (sub > center) {    //새로운 항이 중앙값보다 크다면 그냥 추가합니다.
                push(min_heap, ++im, -sub);
            }
            else if (iM==0 || sub > max_heap[1]) { //중앙값보다 작으나 왼쪽 최대힙의 top보다 크다면 중앙값을 교체하고 원래 중앙값을 오른쪽 최대힙에 추가합니다.
                push(min_heap, ++im, -center);
                center = sub;
            }
            else {    //왼쪽 최대힙의 top값보다 작다면 중앙값->오른쪽 최소 힙 에 추가, 왼쪽 top값 -> 중앙값 , 새로운 항 -> 왼쪽 최대 힙에 추가 합니다.
                push(min_heap, ++im, -center);
                center = max_heap[1];
                replace(max_heap, iM, sub);
            }
        }

        else { //새로운 항을 왼쪽 최대힙에 추가해야할 경우 위와 비슷하게 구성합니다.
            if (sub < center) {
                push(max_heap, ++iM, sub);
            }
            else if(im==0 || sub < -min_heap[1]) {
                push(max_heap, ++iM, center);
                center = sub;
            }
            else {
                push(max_heap, ++iM, center);
                center = -min_heap[1];
                replace(min_heap, im, -sub);
            }
        }
        printf("%d\n", center); //중앙값을 출력합니다.
    }
}
```

![](1019_Cpp_백준_1655_가운데를%20말해요_assets/2022-10-19-15-20-13-image.png)

ㅁㄴ

### 3. 다른풀이와 비교

```cpp
#include <bits/stdc++.h>

using namespace std;

template <class T, class Comp = less<T>>
struct Heap {
	T h[100001], hn = 0;
	void push(T x) {
		int i;
		for (i = ++hn; i >> 1 > 0 && Comp()(h[i >> 1], x); i >>= 1)
			h[i] = h[i >> 1];
		h[i] = x;
	}
	void pop() {
		int i, j, x;
		for (i = 1, x = h[hn--]; i << 1 <= hn; i = j) {
			j = i << 1;
			if (j | 1 <= hn && Comp()(h[j], h[j | 1])) j |= 1;
			if (Comp()(x, h[j])) h[i] = h[j];
			else break;
		}
		h[i] = x;
	}
	int size() { return hn; }
	T& top() { return h[1]; }
};
int main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr);

	Heap<int> mx;
	Heap<int, greater<int>> mn;
	int n;
	cin >> n;
	while (n--) {
		int x; cin >> x;
		if (!mx.size() || mx.top() > x)
			mx.push(x);
		else mn.push(x);
		if (mx.size() > mn.size() + 1) mn.push(mx.top()), mx.pop();
		if (mx.size() < mn.size()) mx.push(mn.top()), mn.pop();
		cout << mx.top() << '\n';
	}
}
```



ㅁㄴ

### 4. 개선 및 후기

ㅁㄴ

###### *출처

https://www.acmicpc.net/problem/1655

- 문제를 각색한 사람: [baekjoon](https://www.acmicpc.net/user/baekjoon)
- 문제를 만든 사람: [ntopia](https://www.acmicpc.net/user/ntopia)
- 데이터를 추가한 사람: [pichulia](https://www.acmicpc.net/user/pichulia)
